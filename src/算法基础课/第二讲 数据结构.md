# 第二讲 数据结构

转载自：
[callmewenhao/AcWing](https://github.com/callmewenhao/AcWing/tree/main)
[acwing常用代码模板2-数据结构](https://www.acwing.com/blog/content/404/)

## 链表

> 使用数组模拟链表

### 单链表

邻接表：存储图和树

- `head` 表示链表的当前的头节点，`head=-1` 表示链表为空
- `e[N]` 存储节点的 value
- `ne[N]` 存储节点的 next 指针
- `idx` 表示当前可以分配的位置，从 0 开始


```C++
// N 是最大的边数，边数的数量级
int head, e[N], ne[N], idx;
//初始化链表
void init() {
    head = -1,;
    idx = 0;
}
// 将 x 插到头结点
void add_to_head(int x) {
    e[idx] = x;     // idx 存的是当前可用的最新的点的下标，存 value
    ne[idx] = head; // 指向 head 指向的值
    head = idx;     // 将 head 指向idx
    idx++;
}
// 在第 k 个插入的数后面插入一个数 x
// 注意 k 从 1 开始，但是 idx 是从 0 开始的，所以应该传入 k-1
void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}
// 删除第 k 个插入的数后面的数
// ** 注意应该传入 k-1 **
void remove(int k) {
    ne[k] = ne[ne[k]];
}
// 遍历链表
for (int i = head; i != -1; i = ne[i])
    cout << e[i] << " ";
```

### 双链表

- `0` 表示左端点 `1` 表示右端点
- `l[N]` 存储左侧节点
- `r[N]` 存储右侧节点
- `idx` 表示当前可以分配的位置


```C++
int m, e[N], l[N], r[N], idx;
// 初始化
void init() {
    // 0 表示左端点head， 1 表示右端点tail
    r[0] = 1, l[1] = 0;
    idx = 2;
}
// 在第 k 个点的右边插入一个点
void add(int k, int x) {
    e[idx] = x;
    // 新插入点的右边 = k点的右边
    r[idx] = r[k];
    // 新插入点的左边 = k
    l[idx] = k;
    // 修改之前的边
    l[r[k]] = idx; // l[r[idx]] = idx
    r[k] = idx++; // r[l[idx]] = idx
}
// 在第 k 个点的左边插入一个点
// == 在第 l[k] 个点的右边插入一个点
// 就是 add(l[k], x)
// 删除第 k 个插入的节点
void remove(int k) {
    // 让左边的右边 = 我的右边
    r[l[k]] = r[k];
    // 让右边的左边 = 我的左边
    l[r[k]] = l[k];
}
// 遍历
for (int i = r[0]; i != 1; i = r[i]) {
    cout << e[i] << " ";
}
```

## 栈


- 栈 -- 先进后出


* `stk[N]` 表示栈
* `tt` 表示栈顶指针
* 插入元素 `stk[++tt] = x`
* 弹出 `tt--`
* 判空 `tt == 0`

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空，如果 tt > 0，则表示不为空
if (tt > 0)
{

}
```

## 队列

- 队列 -- 先进先出
- 队尾插入元素，队头弹出元素


* `q[N]` 队列
* `hh` 头，初始化为 `0`，弹出元素：`hh++`
* `tt` 尾，初始化为 `-1`，插入元素 `x`：`q[++tt] = x`
* 空 `hh > tt`
* 非空 `hh <= tt`
* 对头元素 `q[hh]`

### 1. 普通队列

```cpp
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空，如果 hh <= tt，则表示不为空
if (hh <= tt)
{

}
```

### 2. 循环队列

```cpp
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh != tt，则表示不为空
if (hh != tt)
{

}
```

## 单调栈

单调栈和单调队列精髓在于**单调**，想一下课上的单调函数图

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

> **使用场景**：给一个序列，求每一个数左边离他最近的数在什么地方

找到数组中每一个数 $n_i$ 的

1. **左侧离 $n_i$ 最近且比 $n_i$ 大的数**：从左开始遍历，维护单调栈。如果栈空，则表明左侧没有比 $n_i$ 大的数；如果栈顶大于$n_i$，那么答案就是栈顶；如果栈顶小于等于$n_i$，那么弹出栈顶直到前面的情况出现，最后放入当前的数。

2. **右侧离 $n_i$ 最近且比 $n_i$ 大的数**：从右开始遍历，其他同 1。

3. **左侧离 $n_i$ 最近且比 $n_i$ 小的数**：从左开始遍历，维护单调栈。如果栈空，则表明左侧没有比 $n_i$ 小的数；如果栈顶小于$n_i$，那么答案就是栈顶；如果栈顶大于等于$n_i$，那么弹出栈顶直到前面的情况出现，最后放入当前的数。

4. **右侧离 $n_i$ 最近且比 $n_i$ 小的数**：从右开始遍历，其他同 3。

当需要上述性质时，就是单调栈题目

用数组模拟的好处是可以在栈上进行二分，因为栈上是有序的

``` cpp
#include <iostream>
using namespace std;

int n;
int stk[N], tt;

int main(){
    cin >> n;

    for(int i = 0; i < n; i++){
        int x;
        cin >> x;
        while(tt && stk[tt] >= x) tt--;
        if(tt) cout << stk[tt] << ' ';
        else cout << '-1' << ' ';

        stk[++tt] = x;
    }
}
```

## 单调队列

> **使用场景**：求滑动窗口最大值 or 最小值

注意队列里面存的不是值而是**下标**

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

``` cpp
int hh = 0, tt = -1;
for(int i = 0; i < n; i++){
    // 每次都需要判断队头是否已经滑出窗口
    if(hh <= tt && i - k + 1 > q[hh]) hh++;
    while(hh <= tt && a[q[tt]] >= a[i]) t--;
    q[ ++ tt] = i;
    if(i >= k - 1) printf("%d", a[q[hh]]);
}

// -------摘自github--callmewenhao---------
for (int i = 0; i < n; i++) {
    // 队尾
    while (hh <= tt && a[q[tt]] >= a[i]) {
        tt--;
    }
    // 插入新下标
    q[++tt] = i;
    // 队头 k - 1，这里用 if 就可以，根据题意最多只有1个对头不满足要求
    if (q[hh] <= i - k) hh++;
    // 当下标大于等于 k - 1 时输出答案
    if (i >= k - 1) cout << a[q[hh]] << " ";
}
```

## KMP字符串匹配

原字符串 s[N]，目标串 p[M]，求 p 在 s 中匹配的位置

* 双指针 i 指向原串，j 指向目标串，假设已经有 `s[i-j, i-1] = p[1, j]`

* 如果 `s[i] == p[j+1]`，则 `i++, j++`

* 如果 `s[i] != p[j+1]`，递归地使用 `next[j]` 对应的前缀（或者后缀） 来匹配 `s[i-j, i-1]`
    - 如果，在某次匹配时 `s[i] == p[j+1]` 则递归结束，继续向前移动双指针

    - 可以想象，如果递归过程中，没有发生 `s[i] == p[j+1]`，那意味着最终要下标从 1 匹配，也就回归到暴力了。

**next 数组**：`next[i] = j` 表示 p 中以 i 为终点的后缀 所能匹配的 最长的 与之相等的前缀长度是 j，也就是 p[1, j] = p[i-j+1, i] 且 j 最大。求 next 数组的过程和匹配过程类似


```C++
// y 总下标从 1 开始的模板

// 求 next 数组
// 注意前缀和后缀不能完全重合 所以 next[1] = 0 我们从 2 开始计算 next[i]，另一种解释：当第一个字符都不相等，成功匹配的长度是 0 
for (int i = 2, j = 0; i <= n; i++) {
    while (j && p[i] != p[j + 1])
        j = ne[j];
    if (p[i] == p[j + 1]) j++;
    // 记录一下这个匹配成功的 next 数组值
    ne[i] = j;
}

// KMP 匹配过程
// i 表示目标串正要匹配的字符下标
// j 表示成功匹配的模式串的长度 
// p[j + 1]是模式串要和目标串匹配的字符
for (int i = 1, j = 0; i <= m; i++) {
    // 当已经有匹配的长度 并且 要匹配的字符不相等 修改成功匹配的长度
    while (j && s[i] != p[j + 1])
        j = ne[j];
    if (s[i] == p[j + 1]) j++;  // 成功匹配的个数++
    if (j == n) { // 匹配成功 输出下标
        cout << i - n << " ";
        j = ne[j];  // 匹配成功后 往后退步 但是不必从 1 开始 仍然从能匹配的最大长度开始
    }
}
```

```c++
// 🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀
// 下标从 0 开始的模板
// 求 next 数组
// ne[0] = 0; int j = ne[i - 1];
// i 表示目标串正要匹配的字符下标
// j 表示成功匹配的模式串的长度
for (int i = 1, j = 0; i < n; i++) {
    while (j && p[i] != p[j]) j = ne[j-1];
    if (p[i] == p[j]) j++;
    ne[i] = j;
}

// KMP 匹配过程
for (int i = 0, j = 0; i < m; i++) {
    while (j && s[i] != p[j]) j = ne[j-1];
    if (s[i] == p[j]) j++;
    if (j == n) {
        cout << i - n + 1 << " ";
        j = ne[j-1];
    }
}
```

## Trie树

> 用于快速存储字符串集合的数据结构

```C++
const int N = 100010; // 总点（边）数
int n;  // op 数
int son[N][26], cnt[N], idx; 
// idx表示当前用到了哪个下标，下标是0的点，既是根节点，又是空节点
// son[N][i] 保存每个节点的所有儿子
// cnt[N] 以当前这个点结尾的单词有多少个

// 插入 s
void insert(char str[]) {
    int p = 0; // 头节点
    for (int i = 0; str[i]; i++) {
        int u = s[i] - 'a';  
        if (!son[p][u]) son[p][u] = ++idx; // 孩子的位置
        p = son[p][u]; // 从孩子的 idx 继续找
    }
    cnt[p]++;
}
// 查询 s 返回 s 的个数
int query(char str[]) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = s[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

## 并查集

面试和笔试较容易出现

> **并查集：** (时间近乎O(1))
> 1. 将两个集合合并
> 2. 询问两个元素是否在一个集合中

### 一、原理

- 每个集合用用一棵树来表示

- 树根的编号就是整个集合的编号

- 每个节点存储它的父节点，即 `p[x]` 表示 `x` 的父节点

> Questions：
> 1. 如何判断树根：`p[x] == x `
> 2. 如何求x的集合编号：`while(p[x] != x) x = p[x];`
> 3. 如何合并两个集合：px是x的集合编号，py是y的集合编号。`p[x] = y`，就是把x直接插到y集合

### 二、应用

#### 2.1 find()返回x祖宗节点

``` c++
int find(int x){ 
    // 返回x的祖宗节点＋路径压缩
    // 如果当前节点不是根节点，就返回父节点的祖宗节点
    if(p[x] != x) p[x] = find[p[x]];
    return p[x];
}
```

#### 2.2 合并集合

> 如何合并两个集合：px是x的集合编号，py是y的集合编号。`p[x] = y`，就是把x直接插到y集合

- 合并点`a`和`b`所在的集合，`p[a]`和`p[b]`之间加一条边，让`p[a]`的父节点等于`p[b]`，即`p[find(a)] = find(b)`

``` C++
// 得保证 a 和 b 不在同一集合内部
size[find(a)] += size[find(b)]; // 先合并节点数量
p[find(b)] = find(a);  // 合并操作

// b 所在集合合并到 a 所在集合
int pa = find(a), pb = find(b);
si[pa] += si[pb];
p[pb] = pa;
```

## 堆

### 一、原理

堆是一棵**完全二叉树**，使用一个一维数组存储（注意**下标从 1 开始**，这样方便）

**小根堆**：每个节点的值小于等于其儿子的值，就是每一个根节点值都小于等于其儿子的值。节点 `i` 的左儿子下标是 `i*2`，右儿子下标是 `i*2+1`

**核心操作**

* `down()` 往下调整，元素下沉操作，下沉到合适的位置
* `up()` 往上调整，元素上浮操作，上浮到合适的位置

> 通过这两个核心操作来实现下面这五种操作
> 1. 插入新元素
> 2. 求最小值
> 3. 删除最小值
> 4. 删除任意元素
> 5. 修改任意元素

**1. 插入新元素**：在堆的最后插入一个新元素，然后把这个数上浮到合适的位置  -->  ** *通过上浮up()操作把元素调整到合适位置，即将新插入元素与其根节点比较，使得根节点值是最小的* **

```cpp
heap[++size] = x; // 添加新元素，此时新元素在最后
up(size); // 将新元素上浮到合适位置
```

**2. 求最小值**：由于维护的是最小堆，则最小值就是堆的第一个元素 `heap[1];`

**3. 删除最小值**：很有技巧性，**把堆中最后一个元素覆盖堆顶元素，然后堆大小减一，再下沉 `down(1)`** --> *最小值是第一个元素，就是要删掉第一个元素*

```cpp
heap[1] = heap[size]; // 用最后一个点覆盖掉根节点
size--; // 堆大小减一
down(1); // 让1往下走，下沉
```

**4. 删除任意元素**：比如：删除第 `k` 个元素。*与删除最小值类似*，把第 `k` 个元素用堆中最后一个元素覆盖，然后堆大小减一，然后 `down(k)` `up(k)` 其实 `down(k)` `up(k)` 不会全部执行，只会走其中一个

```cpp
heap[k] = heap[size];
size--;
down(k); up(k); // 实际只会执行一个
```

**5. 修改任意元素**：比如：修改第 `k` 个元素。把第 `k` 个元素用新值覆盖，然后 `down(k)` `up(k)` 不会全部执行，只会走其中一个 --> 与上面一样的，只是没有size--操作

**O(n) 建堆**：从 `n/2` 处开始 `down()`，`n/2` 很妙！总的时间是 O(n) 的👏

## 哈希表

### 存储结构

**拉链法**：先把数字（-1e9~1e9）映射到 0~1e5+3 个槽中（末尾的数字建议是质数），然后在 0~1e5+3 的每个槽建一个链表存数字（数组模拟即可）

```cpp
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }
```

**开放寻址法**：只开了一个数组 数据范围的 2~3 倍，如果当前坑位有人 就继续向后找位置

```cpp
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```

### 字符串哈希

这里的哈希方式是指 **字符串前缀哈希法**

> 通常用于快速判断两个字符串是否相等，O(1)

**计算哈希值**：把字符串看成是一个 `p` 进制的数，然后把 `p` 进制的数转成 `10` 进制的数（数可能很大），取模 `Q`，使得映射范围变为`0 ~ Q-1`

**注意**：
- 不能把字母映射成 `0` 而是从 `1` 开始。因为如果把数字映射成 `0` 就会出现 `A=0 AA=00=0 AAA=000=0 ...`  无法区分的情况
- 不考虑冲突情况，经验值取 `p = 131 or 13331 & Q = 2^64` 时，一般不会冲突
- 另外，我们可以使用 `unsigned long long` 存数字，这样当数字溢出时，就会**自动取模**

利用上述计算方式，计算所有的**字符串前缀哈希值**。

> 可以使用 `h[l-1] h[r]` 求出字串 `[l, r]` 的哈希值，计算公式：`h[r] - h[l - 1] * p ^ (r - l + 1)`。注意：左边是高位，右边是低位

```cpp
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```