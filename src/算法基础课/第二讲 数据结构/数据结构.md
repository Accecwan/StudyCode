# 第二讲 数据结构

## 链表

> 使用数组模拟链表

### 单链表

邻接表：存储图和树

- `head` 表示链表的当前的头节点，`head=-1` 表示链表为空
- `e[N]` 存储节点的 value
- `ne[N]` 存储节点的 next 指针
- `idx` 表示当前可以分配的位置，从 0 开始


```C++
// N 是最大的边数，边数的数量级
int head, e[N], ne[N], idx;
//初始化链表
void init() {
    head = -1,;
    idx = 0;
}
// 将 x 插到头结点
void add_to_head(int x) {
    e[idx] = x;     // idx 存的是当前可用的最新的点的下标，存 value
    ne[idx] = head; // 指向 head 指向的值
    head = idx;     // 将 head 指向idx
    idx++;
}
// 在第 k 个插入的数后面插入一个数 x
// 注意 k 从 1 开始，但是 idx 是从 0 开始的，所以应该传入 k-1
void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}
// 删除第 k 个插入的数后面的数
// ** 注意应该传入 k-1 **
void remove(int k) {
    ne[k] = ne[ne[k]];
}
// 遍历链表
for (int i = head; i != -1; i = ne[i])
    cout << e[i] << " ";
```

### 双链表

- `0` 表示左端点 `1` 表示右端点
- `l[N]` 存储左侧节点
- `r[N]` 存储右侧节点
- `idx` 表示当前可以分配的位置


```C++
int m, e[N], l[N], r[N], idx;
// 初始化
void init() {
    // 0 表示左端点head， 1 表示右端点tail
    r[0] = 1, l[1] = 0;
    idx = 2;
}
// 在第 k 个点的右边插入一个点
void add(int k, int x) {
    e[idx] = x;
    // 新插入点的右边 = k点的右边
    r[idx] = r[k];
    // 新插入点的左边 = k
    l[idx] = k;
    // 修改之前的边
    l[r[k]] = idx; // l[r[idx]] = idx
    r[k] = idx++; // r[l[idx]] = idx
}
// 在第 k 个点的左边插入一个点
// == 在第 l[k] 个点的右边插入一个点
// 就是 add(l[k], x)
// 删除第 k 个插入的节点
void remove(int k) {
    // 让左边的右边 = 我的右边
    r[l[k]] = r[k];
    // 让右边的左边 = 我的左边
    l[r[k]] = l[k];
}
// 遍历
for (int i = r[0]; i != 1; i = r[i]) {
    cout << e[i] << " ";
}
```

## 栈


- 栈 -- 先进后出


* `stk[N]` 表示栈
* `tt` 表示栈顶指针
* 插入元素 `stk[++tt] = x`
* 弹出 `tt--`
* 判空 `tt == 0`

## 队列

- 队列 -- 先进先出
- 队尾插入元素，队头弹出元素


* `q[N]` 队列
* `hh` 头，初始化为 `0`，弹出元素：`hh++`
* `tt` 尾，初始化为 `-1`，插入元素 `x`：`q[++tt] = x`
* 空 `hh > tt`
* 非空 `hh <= tt`
* 对头元素 `q[hh]`

## 单调栈

单调栈和单调队列精髓在于**单调**，想一下课上的单调函数图

> **使用场景**：给一个序列，求每一个数左边离他最近的数在什么地方

找到数组中每一个数 $n_i$ 的

1. **左侧离 $n_i$ 最近且比 $n_i$ 大的数**：从左开始遍历，维护单调栈。如果栈空，则表明左侧没有比 $n_i$ 大的数；如果栈顶大于$n_i$，那么答案就是栈顶；如果栈顶小于等于$n_i$，那么弹出栈顶直到前面的情况出现，最后放入当前的数。

2. **右侧离 $n_i$ 最近且比 $n_i$ 大的数**：从右开始遍历，其他同 1。

3. **左侧离 $n_i$ 最近且比 $n_i$ 小的数**：从左开始遍历，维护单调栈。如果栈空，则表明左侧没有比 $n_i$ 小的数；如果栈顶小于$n_i$，那么答案就是栈顶；如果栈顶大于等于$n_i$，那么弹出栈顶直到前面的情况出现，最后放入当前的数。

4. **右侧离 $n_i$ 最近且比 $n_i$ 小的数**：从右开始遍历，其他同 3。

当需要上述性质时，就是单调栈题目

用数组模拟的好处是可以在栈上进行二分，因为栈上是有序的

``` cpp
#include <iostream>
using namespace std;

int n;
int stk[N], tt;

int main(){
    cin >> n;

    for(int i = 0; i < n; i++){
        int x;
        cin >> x;
        while(tt && stk[tt] >= x) tt--;
        if(tt) cout << stk[tt] << ' ';
        else cout << '-1' << ' ';

        stk[++tt] = x;
    }
}
```

## 单调队列

> **使用场景**：求滑动窗口最大值 or 最小值

注意队列里面存的不是值而是**下标**

``` cpp
int hh = 0, tt = -1;
for(int i = 0; i < n; i++){
    // 每次都需要判断队头是否已经滑出窗口
    if(hh <= tt && i - k + 1 > q[hh]) hh++;
    while(hh <= tt && a[q[tt]] >= a[i]) t--;
    q[ ++ tt] = i;
    if(i >= k - 1) printf("%d", a[q[hh]]);
}

// -------摘自github--callmewenhao---------
for (int i = 0; i < n; i++) {
    // 队尾
    while (hh <= tt && a[q[tt]] >= a[i]) {
        tt--;
    }
    // 插入新下标
    q[++tt] = i;
    // 队头 k - 1，这里用 if 就可以，根据题意最多只有1个对头不满足要求
    if (q[hh] <= i - k) hh++;
    // 当下标大于等于 k - 1 时输出答案
    if (i >= k - 1) cout << a[q[hh]] << " ";
}
```

## KMP字符串匹配

原字符串 s[N]，目标串 p[M]，求 p 在 s 中匹配的位置

* 双指针 i 指向原串，j 指向目标串，假设已经有 `s[i-j, i-1] = p[1, j]`

* 如果 `s[i] == p[j+1]`，则 `i++, j++`

* 如果 `s[i] != p[j+1]`，递归地使用 `next[j]` 对应的前缀（或者后缀） 来匹配 `s[i-j, i-1]`
    - 如果，在某次匹配时 `s[i] == p[j+1]` 则递归结束，继续向前移动双指针

    - 可以想象，如果递归过程中，没有发生 `s[i] == p[j+1]`，那意味着最终要下标从 1 匹配，也就回归到暴力了。

**next 数组**：`next[i] = j` 表示 p 中以 i 为终点的后缀 所能匹配的 最长的 与之相等的前缀长度是 j，也就是 p[1, j] = p[i-j+1, i] 且 j 最大。求 next 数组的过程和匹配过程类似


```C++
// y 总下标从 1 开始的模板

// 求 next 数组
// 注意前缀和后缀不能完全重合 所以 next[1] = 0 我们从 2 开始计算 next[i]，另一种解释：当第一个字符都不相等，成功匹配的长度是 0 
for (int i = 2, j = 0; i <= n; i++) {
    while (j && p[i] != p[j + 1])
        j = ne[j];
    if (p[i] == p[j + 1]) j++;
    // 记录一下这个匹配成功的 next 数组值
    ne[i] = j;
}

// KMP 匹配过程
// i 表示目标串正要匹配的字符下标
// j 表示成功匹配的模式串的长度 
// p[j + 1]是模式串要和目标串匹配的字符
for (int i = 1, j = 0; i <= m; i++) {
    // 当已经有匹配的长度 并且 要匹配的字符不相等 修改成功匹配的长度
    while (j && s[i] != p[j + 1])
        j = ne[j];
    if (s[i] == p[j + 1]) j++;  // 成功匹配的个数++
    if (j == n) { // 匹配成功 输出下标
        cout << i - n << " ";
        j = ne[j];  // 匹配成功后 往后退步 但是不必从 1 开始 仍然从能匹配的最大长度开始
    }
}
```

```c++
// 🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀🚀
// 下标从 0 开始的模板
// 求 next 数组
// ne[0] = 0; int j = ne[i - 1];
// i 表示目标串正要匹配的字符下标
// j 表示成功匹配的模式串的长度
for (int i = 1, j = 0; i < n; i++) {
    while (j && p[i] != p[j]) j = ne[j-1];
    if (p[i] == p[j]) j++;
    ne[i] = j;
}

// KMP 匹配过程
for (int i = 0, j = 0; i < m; i++) {
    while (j && s[i] != p[j]) j = ne[j-1];
    if (s[i] == p[j]) j++;
    if (j == n) {
        cout << i - n + 1 << " ";
        j = ne[j-1];
    }
}
```

## Trie树

> 用于快速存储字符串集合的数据结构

```C++
const int N = 100010; // 总点（边）数
int n;  // op 数
int son[N][26], cnt[N], idx; // 下标是0的点，既是根节点，又是空节点
// 插入 s
void insert(char str[]) {
    int p = 0; // 头节点
    for (int i = 0; str[i]; i++) {
        int u = s[i] - 'a';  
        if (!son[p][u]) son[p][u] = ++idx; // 孩子的位置
        p = son[p][u]; // 从孩子的 idx 继续找
    }
    cnt[p]++;
}
// 查询 s 返回 s 的个数
int query(char str[]) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int u = s[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```



