# 第二讲 数据结构

## 链表

> 使用数组模拟链表

### 单链表

邻接表：存储图和树

- `head` 表示链表的当前的头节点，`head=-1` 表示链表为空
- `e[N]` 存储节点的 value
- `ne[N]` 存储节点的 next 指针
- `idx` 表示当前可以分配的位置，从 0 开始


```C++
// N 是最大的边数，边数的数量级
int head, e[N], ne[N], idx;
//初始化链表
void init() {
    head = -1,;
    idx = 0;
}
// 将 x 插到头结点
void add_to_head(int x) {
    e[idx] = x;     // idx 存的是当前可用的最新的点的下标，存 value
    ne[idx] = head; // 指向 head 指向的值
    head = idx;     // 将 head 指向idx
    idx++;
}
// 在第 k 个插入的数后面插入一个数 x
// 注意 k 从 1 开始，但是 idx 是从 0 开始的，所以应该传入 k-1
void add(int k, int x) {
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx;
    idx++;
}
// 删除第 k 个插入的数后面的数
// ** 注意应该传入 k-1 **
void remove(int k) {
    ne[k] = ne[ne[k]];
}
// 遍历链表
for (int i = head; i != -1; i = ne[i])
    cout << e[i] << " ";
```

### 双链表

- `0` 表示左端点 `1` 表示右端点
- `l[N]` 存储左侧节点
- `r[N]` 存储右侧节点
- `idx` 表示当前可以分配的位置


```C++
int m, e[N], l[N], r[N], idx;
// 初始化
void init() {
    // 0 表示左端点head， 1 表示右端点tail
    r[0] = 1, l[1] = 0;
    idx = 2;
}
// 在第 k 个点的右边插入一个点
void add(int k, int x) {
    e[idx] = x;
    // 新插入点的右边 = k点的右边
    r[idx] = r[k];
    // 新插入点的左边 = k
    l[idx] = k;
    // 修改之前的边
    l[r[k]] = idx; // l[r[idx]] = idx
    r[k] = idx++; // r[l[idx]] = idx
}
// 在第 k 个点的左边插入一个点
// == 在第 l[k] 个点的右边插入一个点
// 就是 add(l[k], x)
// 删除第 k 个插入的节点
void remove(int k) {
    // 让左边的右边 = 我的右边
    r[l[k]] = r[k];
    // 让右边的左边 = 我的左边
    l[r[k]] = l[k];
}
// 遍历
for (int i = r[0]; i != 1; i = r[i]) {
    cout << e[i] << " ";
}
```

## 栈


- 栈 -- 先进后出


* `stk[N]` 表示栈
* `tt` 表示栈顶指针
* 插入元素 `stk[++tt] = x`
* 弹出 `tt--`
* 判空 `tt == 0`

## 队列

- 队列 -- 先进先出
- 队尾插入元素，队头弹出元素


* `q[N]` 队列
* `hh` 头，初始化为 `0`，弹出元素：`hh++`
* `tt` 尾，初始化为 `-1`，插入元素 `x`：`q[++tt] = x`
* 空 `hh > tt`
* 非空 `hh <= tt`
* 对头元素 `q[hh]`

## 单调栈

找到数组中每一个数 $n_i$ 的

1. **左侧离 $n_i$ 最近且比 $n_i$ 大的数**：从左开始遍历，维护单调栈。如果栈空，则表明左侧没有比 $n_i$ 大的数；如果栈顶大于$n_i$，那么答案就是栈顶；如果栈顶小于等于$n_i$，那么弹出栈顶直到前面的情况出现，最后放入当前的数。

2. **右侧离 $n_i$ 最近且比 $n_i$ 大的数**：从右开始遍历，其他同 1。

3. **左侧离 $n_i$ 最近且比 $n_i$ 小的数**：从左开始遍历，维护单调栈。如果栈空，则表明左侧没有比 $n_i$ 小的数；如果栈顶小于$n_i$，那么答案就是栈顶；如果栈顶大于等于$n_i$，那么弹出栈顶直到前面的情况出现，最后放入当前的数。

4. **右侧离 $n_i$ 最近且比 $n_i$ 小的数**：从右开始遍历，其他同 3。

当需要上述性质时，就是单调栈题目

用数组模拟的好处是可以在栈上进行二分，因为栈上是有序的





